===== FULL FILE DUMP =====

===== FILE: C:\esp\my_host_project\my_app\main\portal_wifi.c =====
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "esp_log.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_http_server.h"
#include "esp_spiffs.h"
#include "cJSON.h"

#include "dns_hijack.h"
#include "config_store.h"
#include "footswitch.h"

static const char *TAG = "PORTAL";
static httpd_handle_t s_http = NULL;

static inline int wrapi(int v, int max)
{
    if (max <= 0) return 0;
    int r = v % max;
    if (r < 0) r += max;
    return r;
}

static esp_err_t send_spiffs_file(httpd_req_t *req, const char *path, const char *ctype)
{
    FILE *f = fopen(path, "rb");
    if (!f) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "file not found");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, ctype);

    char buf[1024];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (httpd_resp_send_chunk(req, buf, n) != ESP_OK) {
            fclose(f);
            httpd_resp_sendstr_chunk(req, NULL);
            return ESP_FAIL;
        }
    }

    fclose(f);
    httpd_resp_sendstr_chunk(req, NULL);
    return ESP_OK;
}

// -------- Static files --------
static esp_err_t h_root(httpd_req_t *req) { return send_spiffs_file(req, "/spiffs/index.html", "text/html"); }
static esp_err_t h_js(httpd_req_t *req)   { return send_spiffs_file(req, "/spiffs/app.js", "application/javascript"); }
static esp_err_t h_css(httpd_req_t *req)  { return send_spiffs_file(req, "/spiffs/style.css", "text/css"); }

// -------- Captive portal detection endpoints (redirect to /) --------
static esp_err_t h_redirect_to_root(httpd_req_t *req)
{
    httpd_resp_set_status(req, "302 Found");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

static esp_err_t h_generate_204(httpd_req_t *req) { return h_redirect_to_root(req); }
static esp_err_t h_hotspot(httpd_req_t *req)      { return h_redirect_to_root(req); }
static esp_err_t h_ncsi(httpd_req_t *req)         { return h_redirect_to_root(req); }

// -------- API: META --------
static esp_err_t h_get_meta(httpd_req_t *req)
{
    char out[220];
    int bc = config_store_bank_count();
    snprintf(out, sizeof(out),
             "{\"maxBanks\":%d,\"maxPages\":%d,\"buttons\":%d,\"bankCount\":%d,\"maxActions\":%d,\"longMs\":%d}",
             MAX_BANKS, MAX_PAGES, NUM_BTNS, bc, MAX_ACTIONS, 400);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

// -------- API: LAYOUT --------
static esp_err_t h_get_layout(httpd_req_t *req)
{
    // ✅ FIX: layout json ใหญ่กว่า 4096 ได้ (ไม่งั้น add bank/page fail)
    const int OUT_MAX = 16384;
    char *json = (char *)calloc(1, OUT_MAX);
    if (!json) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    if (config_store_get_layout_json(json, OUT_MAX) != ESP_OK) {
        free(json);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "layout read failed");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    free(json);
    return ESP_OK;
}

static esp_err_t h_post_layout(httpd_req_t *req)
{
    // ✅ FIX: รับ body ใหญ่ขึ้น
    const int MAX_BODY = 16384;

    int total = req->content_len;
    if (total <= 0 || total > MAX_BODY) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_layout_json(buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "layout invalid");
        return ESP_FAIL;
    }

    footswitch_state_t st = footswitch_get_state();
    footswitch_set_state(st.bank, st.page);

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: state --------
static esp_err_t h_get_state(httpd_req_t *req)
{
    footswitch_state_t st = footswitch_get_state();
    char out[128];
    snprintf(out, sizeof(out), "{\"bank\":%u,\"page\":%u}", (unsigned)st.bank, (unsigned)st.page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

static esp_err_t h_post_state(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 256) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char buf[257];
    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    cJSON *root = cJSON_Parse(buf);
    if (!root) { httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json"); return ESP_FAIL; }

    cJSON *jb = cJSON_GetObjectItem(root, "bank");
    cJSON *jp = cJSON_GetObjectItem(root, "page");
    if (!cJSON_IsNumber(jb) || !cJSON_IsNumber(jp)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json fields");
        return ESP_FAIL;
    }

    int bc = config_store_bank_count();
    int bank = wrapi(jb->valueint, bc);
    int pc = config_store_page_count(bank);
    int page = wrapi(jp->valueint, pc);

    footswitch_set_state(bank, page);
    cJSON_Delete(root);

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: per-button mapping --------
static esp_err_t h_get_button(httpd_req_t *req)
{
    char q[96] = {0};
    int bank = 0, page = 0, btn = 0;

    if (httpd_req_get_url_query_str(req, q, sizeof(q)) == ESP_OK) {
        char tmp[16];
        if (httpd_query_key_value(q, "bank", tmp, sizeof(tmp)) == ESP_OK) bank = atoi(tmp);
        if (httpd_query_key_value(q, "page", tmp, sizeof(tmp)) == ESP_OK) page = atoi(tmp);
        if (httpd_query_key_value(q, "btn",  tmp, sizeof(tmp)) == ESP_OK) btn  = atoi(tmp);
    }

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    // ✅ FIX: button json ใหญ่ขึ้น (เพราะ MAX_ACTIONS=20)
    const int OUT_MAX = 8192;
    char *json = (char *)calloc(1, OUT_MAX);
    if (!json) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    if (config_store_get_btn_json(bank, page, btn, json, OUT_MAX) != ESP_OK) {
        free(json);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "button read failed");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    free(json);
    return ESP_OK;
}

static esp_err_t h_post_button(httpd_req_t *req)
{
    char q[96] = {0};
    int bank = 0, page = 0, btn = 0;

    if (httpd_req_get_url_query_str(req, q, sizeof(q)) == ESP_OK) {
        char tmp[16];
        if (httpd_query_key_value(q, "bank", tmp, sizeof(tmp)) == ESP_OK) bank = atoi(tmp);
        if (httpd_query_key_value(q, "page", tmp, sizeof(tmp)) == ESP_OK) page = atoi(tmp);
        if (httpd_query_key_value(q, "btn",  tmp, sizeof(tmp)) == ESP_OK) btn  = atoi(tmp);
    }

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    // ✅ FIX: body ใหญ่ขึ้น
    const int MAX_BODY = 8192;
    int total = req->content_len;
    if (total <= 0 || total > MAX_BODY) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_btn_json(bank, page, btn, buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "button config invalid");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

static void start_http_server(void)
{
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    cfg.max_uri_handlers = 40;

    ESP_ERROR_CHECK(httpd_start(&s_http, &cfg));

    httpd_uri_t u_root = { .uri="/", .method=HTTP_GET, .handler=h_root };
    httpd_uri_t u_js   = { .uri="/app.js", .method=HTTP_GET, .handler=h_js };
    httpd_uri_t u_css  = { .uri="/style.css", .method=HTTP_GET, .handler=h_css };

    httpd_uri_t u_204  = { .uri="/generate_204", .method=HTTP_GET, .handler=h_generate_204 };
    httpd_uri_t u_hot  = { .uri="/hotspot-detect.html", .method=HTTP_GET, .handler=h_hotspot };
    httpd_uri_t u_ncsi = { .uri="/ncsi.txt", .method=HTTP_GET, .handler=h_ncsi };
    httpd_uri_t u_ct   = { .uri="/connecttest.txt", .method=HTTP_GET, .handler=h_ncsi };

    httpd_uri_t u_meta   = { .uri="/api/meta",   .method=HTTP_GET,  .handler=h_get_meta };
    httpd_uri_t u_layout = { .uri="/api/layout", .method=HTTP_GET,  .handler=h_get_layout };
    httpd_uri_t u_pl     = { .uri="/api/layout", .method=HTTP_POST, .handler=h_post_layout };

    httpd_uri_t u_gs   = { .uri="/api/state", .method=HTTP_GET,  .handler=h_get_state };
    httpd_uri_t u_ps   = { .uri="/api/state", .method=HTTP_POST, .handler=h_post_state };

    httpd_uri_t u_gb   = { .uri="/api/button", .method=HTTP_GET,  .handler=h_get_button };
    httpd_uri_t u_pb   = { .uri="/api/button", .method=HTTP_POST, .handler=h_post_button };

    httpd_register_uri_handler(s_http, &u_root);
    httpd_register_uri_handler(s_http, &u_js);
    httpd_register_uri_handler(s_http, &u_css);

    httpd_register_uri_handler(s_http, &u_204);
    httpd_register_uri_handler(s_http, &u_hot);
    httpd_register_uri_handler(s_http, &u_ncsi);
    httpd_register_uri_handler(s_http, &u_ct);

    httpd_register_uri_handler(s_http, &u_meta);
    httpd_register_uri_handler(s_http, &u_layout);
    httpd_register_uri_handler(s_http, &u_pl);

    httpd_register_uri_handler(s_http, &u_gs);
    httpd_register_uri_handler(s_http, &u_ps);

    httpd_register_uri_handler(s_http, &u_gb);
    httpd_register_uri_handler(s_http, &u_pb);

    ESP_LOGI(TAG, "HTTP server started");
}

static void mount_spiffs(void)
{
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 8,
        .format_if_mount_failed = true,
    };
    ESP_ERROR_CHECK(esp_vfs_spiffs_register(&conf));
    ESP_LOGI(TAG, "SPIFFS mounted");
}

void portal_wifi_start(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    esp_netif_create_default_wifi_ap();

    wifi_init_config_t wicfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&wicfg));

    wifi_config_t ap = { 0 };
    strcpy((char*)ap.ap.ssid, "FOOTSWITCH-SETUP");
    strcpy((char*)ap.ap.password, "12345678");
    ap.ap.ssid_len = 0;
    ap.ap.max_connection = 2;
    ap.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    if (strlen((char*)ap.ap.password) == 0) ap.ap.authmode = WIFI_AUTH_OPEN;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap));
    ESP_ERROR_CHECK(esp_wifi_start());

    mount_spiffs();

    dns_hijack_start();
    start_http_server();

    ESP_LOGI(TAG, "Captive portal ready. Connect Wi-Fi 'FOOTSWITCH-SETUP' then open 192.168.4.1");
}


===== END FILE: C:\esp\my_host_project\my_app\main\portal_wifi.c =====

===== FILE: C:\esp\my_host_project\my_app\main\config_store.c =====
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "esp_log.h"
#include "esp_err.h"
#include "nvs.h"
#include "nvs_flash.h"
#include "cJSON.h"

#include "config_store.h"

static const char *TAG = "CFG";

static foot_config_t s_cfg;

#define CFG_MAGIC 0x46435346u  // 'FSCF'
#define CFG_VER   3            // ✅ bump to v3 (pressMode 3 ค่า + MAX_ACTIONS 20)

// ---- legacy blobs (เพื่ออ่านของเก่าได้) ----
// v1 (เดิม): size เป็น uint16_t ทำให้ล้นเมื่อ struct ใหญ่
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t ver;
    uint16_t size;      // BUG: overflow for big cfg
    foot_config_t cfg;
} cfg_blob_v1_t;

// v2 (เคยแก้): size เป็น uint32_t แต่เป็น “ก้อนเดียว” ทำให้ต้อง malloc ใหญ่ตอน save
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t ver;
    uint16_t reserved;
    uint32_t size;
    foot_config_t cfg;
} cfg_blob_v2_t;

// v3 (ใหม่): แยก header + data ลดการ malloc ก้อนใหญ่
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t ver;
    uint16_t reserved;
    uint32_t size;
} cfg_hdr_v3_t;

static inline int clampi(int v, int lo, int hi)
{
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

static inline int wrapi(int v, int max)
{
    if (max <= 0) return 0;
    int r = v % max;
    if (r < 0) r += max;
    return r;
}

static void set_default_action(action_t *a)
{
    if (!a) return;
    a->type = ACT_NONE;
    a->ch   = 1;
    a->a    = 0;
    a->b    = 0;
    a->c    = 0;
}

static void safe_set_name(char dst[NAME_LEN], const char *src, const char *fallback)
{
    const char *s = (src && src[0]) ? src : fallback;
    if (!s) s = "";
    strncpy(dst, s, NAME_LEN - 1);
    dst[NAME_LEN - 1] = 0;
}

static void set_defaults(void)
{
    memset(&s_cfg, 0, sizeof(s_cfg));

    s_cfg.bank_count = MAX_BANKS;
    for (int b = 0; b < MAX_BANKS; b++) {
        s_cfg.page_count[b] = MAX_PAGES;

        char bn[NAME_LEN];
        snprintf(bn, sizeof(bn), "Bank %d", b + 1);
        safe_set_name(s_cfg.bank_name[b], bn, "Bank");

        for (int p = 0; p < MAX_PAGES; p++) {
            char pn[NAME_LEN];
            snprintf(pn, sizeof(pn), "Page %d", p + 1);
            safe_set_name(s_cfg.page_name[b][p], pn, "Page");

            for (int k = 0; k < NUM_BTNS; k++) {
                btn_map_t *m = &s_cfg.map[b][p][k];
                m->press_mode  = BTN_SHORT;
                m->cc_behavior = CC_NORMAL;
                for (int i = 0; i < MAX_ACTIONS; i++) {
                    set_default_action(&m->short_actions[i]);
                    set_default_action(&m->long_actions[i]);
                }
            }
        }
    }
}

// ---------- NVS load/save ----------
static esp_err_t nvs_load_v3(foot_config_t *out)
{
    if (!out) return ESP_ERR_INVALID_ARG;

    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READONLY, &h);
    if (e != ESP_OK) return e;

    size_t hlen = sizeof(cfg_hdr_v3_t);
    cfg_hdr_v3_t hdr;
    e = nvs_get_blob(h, "cfg_hdr", &hdr, &hlen);
    if (e != ESP_OK || hlen != sizeof(cfg_hdr_v3_t)) {
        nvs_close(h);
        return ESP_FAIL;
    }

    if (hdr.magic != CFG_MAGIC || hdr.ver != CFG_VER || hdr.size != sizeof(foot_config_t)) {
        nvs_close(h);
        return ESP_FAIL;
    }

    size_t dlen = 0;
    e = nvs_get_blob(h, "cfg_data", NULL, &dlen);
    if (e != ESP_OK || dlen != sizeof(foot_config_t)) {
        nvs_close(h);
        return ESP_FAIL;
    }

    e = nvs_get_blob(h, "cfg_data", out, &dlen);
    nvs_close(h);
    return e;
}

static esp_err_t nvs_load_legacy(foot_config_t *out)
{
    if (!out) return ESP_ERR_INVALID_ARG;

    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READONLY, &h);
    if (e != ESP_OK) return e;

    size_t len = 0;
    e = nvs_get_blob(h, "cfg_blob", NULL, &len);
    if (e != ESP_OK) { nvs_close(h); return e; }

    uint8_t *buf = (uint8_t *)malloc(len);
    if (!buf) { nvs_close(h); return ESP_ERR_NO_MEM; }

    e = nvs_get_blob(h, "cfg_blob", buf, &len);
    nvs_close(h);
    if (e != ESP_OK) { free(buf); return e; }

    // v2
    if (len == sizeof(cfg_blob_v2_t)) {
        const cfg_blob_v2_t *b = (const cfg_blob_v2_t *)buf;
        if (b->magic == CFG_MAGIC && b->ver == 2 && b->size == sizeof(foot_config_t)) {
            memcpy(out, &b->cfg, sizeof(*out));
            free(buf);
            return ESP_OK;
        }
        free(buf);
        return ESP_FAIL;
    }

    // v1
    if (len == sizeof(cfg_blob_v1_t)) {
        const cfg_blob_v1_t *b1 = (const cfg_blob_v1_t *)buf;
        if (b1->magic == CFG_MAGIC && b1->ver == 1) {
            memcpy(out, &b1->cfg, sizeof(*out));
            free(buf);
            return ESP_OK;
        }
        free(buf);
        return ESP_FAIL;
    }

    free(buf);
    return ESP_FAIL;
}

static esp_err_t nvs_save_v3(const foot_config_t *in)
{
    if (!in) return ESP_ERR_INVALID_ARG;

    cfg_hdr_v3_t hdr;
    memset(&hdr, 0, sizeof(hdr));
    hdr.magic = CFG_MAGIC;
    hdr.ver   = CFG_VER;
    hdr.size  = (uint32_t)sizeof(foot_config_t);

    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READWRITE, &h);
    if (e != ESP_OK) return e;

    e = nvs_set_blob(h, "cfg_hdr", &hdr, sizeof(hdr));
    if (e == ESP_OK) e = nvs_set_blob(h, "cfg_data", in, sizeof(*in));
    if (e == ESP_OK) e = nvs_commit(h);
    nvs_close(h);

    if (e != ESP_OK) ESP_LOGE(TAG, "nvs_save_v3 failed: %s", esp_err_to_name(e));
    return e;
}

const foot_config_t *config_store_get(void)
{
    return &s_cfg;
}

void config_store_init(void)
{
    esp_err_t e = nvs_flash_init();
    if (e == ESP_ERR_NVS_NO_FREE_PAGES || e == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS needs erase (e=%s)", esp_err_to_name(e));
        ESP_ERROR_CHECK(nvs_flash_erase());
        e = nvs_flash_init();
    }
    ESP_ERROR_CHECK(e);

    set_defaults();

    // v3 ก่อน
    e = nvs_load_v3(&s_cfg);
    if (e == ESP_OK) {
        ESP_LOGI(TAG, "Loaded config v3 from NVS");
    } else {
        // ลอง legacy
        e = nvs_load_legacy(&s_cfg);
        if (e == ESP_OK) {
            ESP_LOGW(TAG, "Loaded legacy config; migrating to v3");
            (void)nvs_save_v3(&s_cfg);
        } else {
            ESP_LOGW(TAG, "No saved config, using defaults");
            (void)nvs_save_v3(&s_cfg);
        }
    }

    // sanitize counts
    s_cfg.bank_count = (uint8_t)clampi((int)s_cfg.bank_count, 1, MAX_BANKS);
    for (int b = 0; b < MAX_BANKS; b++) {
        s_cfg.page_count[b] = (uint8_t)clampi((int)s_cfg.page_count[b], 1, MAX_PAGES);
        s_cfg.bank_name[b][NAME_LEN - 1] = 0;
        for (int p = 0; p < MAX_PAGES; p++) s_cfg.page_name[b][p][NAME_LEN - 1] = 0;
    }
}

// ---- layout helpers ----
int config_store_bank_count(void)
{
    return (int)clampi((int)s_cfg.bank_count, 1, MAX_BANKS);
}

int config_store_page_count(int bank)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    return (int)clampi((int)s_cfg.page_count[bank], 1, MAX_PAGES);
}

const char *config_store_bank_name(int bank)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    return s_cfg.bank_name[bank];
}

const char *config_store_page_name(int bank, int page)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    return s_cfg.page_name[bank][page];
}

esp_err_t config_store_get_layout_json(char *out, int out_len)
{
    if (!out || out_len <= 0) return ESP_ERR_INVALID_ARG;

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "maxBanks", MAX_BANKS);
    cJSON_AddNumberToObject(root, "maxPages", MAX_PAGES);

    int bc = config_store_bank_count();
    cJSON_AddNumberToObject(root, "bankCount", bc);

    cJSON *banks = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "banks", banks);

    for (int b = 0; b < bc; b++) {
        cJSON *bo = cJSON_CreateObject();
        cJSON_AddNumberToObject(bo, "index", b);
        cJSON_AddStringToObject(bo, "name", s_cfg.bank_name[b]);

        int pc = (int)clampi((int)s_cfg.page_count[b], 1, MAX_PAGES);
        cJSON_AddNumberToObject(bo, "pageCount", pc);

        cJSON *pages = cJSON_CreateArray();
        cJSON_AddItemToObject(bo, "pages", pages);
        for (int p = 0; p < pc; p++) {
            cJSON_AddItemToArray(pages, cJSON_CreateString(s_cfg.page_name[b][p]));
        }

        cJSON_AddItemToArray(banks, bo);
    }

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) {
        free(s);
        return ESP_FAIL;
    }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}

esp_err_t config_store_set_layout_json(const char *json)
{
    if (!json) return ESP_ERR_INVALID_ARG;

    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *jbc = cJSON_GetObjectItem(root, "bankCount");
    cJSON *jbanks = cJSON_GetObjectItem(root, "banks");
    if (!cJSON_IsNumber(jbc) || !cJSON_IsArray(jbanks)) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    int bc = clampi(jbc->valueint, 1, MAX_BANKS);

    uint8_t new_bank_count = (uint8_t)bc;
    uint8_t new_page_count[MAX_BANKS];
    char new_bank_name[MAX_BANKS][NAME_LEN];
    char new_page_name[MAX_BANKS][MAX_PAGES][NAME_LEN];

    memcpy(new_page_count, s_cfg.page_count, sizeof(new_page_count));
    memcpy(new_bank_name, s_cfg.bank_name, sizeof(new_bank_name));
    memcpy(new_page_name, s_cfg.page_name, sizeof(new_page_name));

    for (int b = 0; b < bc; b++) {
        cJSON *bo = cJSON_GetArrayItem(jbanks, b);
        if (!cJSON_IsObject(bo)) { cJSON_Delete(root); return ESP_FAIL; }

        cJSON *bn = cJSON_GetObjectItem(bo, "name");
        cJSON *pc = cJSON_GetObjectItem(bo, "pageCount");
        cJSON *pages = cJSON_GetObjectItem(bo, "pages");

        if (cJSON_IsString(bn)) safe_set_name(new_bank_name[b], bn->valuestring, new_bank_name[b]);
        else safe_set_name(new_bank_name[b], NULL, new_bank_name[b]);

        int pcount = cJSON_IsNumber(pc) ? clampi(pc->valueint, 1, MAX_PAGES)
                                        : clampi((int)new_page_count[b], 1, MAX_PAGES);
        new_page_count[b] = (uint8_t)pcount;

        if (cJSON_IsArray(pages)) {
            int n = cJSON_GetArraySize(pages);
            if (n > pcount) n = pcount;
            for (int p = 0; p < n; p++) {
                cJSON *ps = cJSON_GetArrayItem(pages, p);
                if (cJSON_IsString(ps)) {
                    safe_set_name(new_page_name[b][p], ps->valuestring, new_page_name[b][p]);
                }
            }
        }

        new_bank_name[b][NAME_LEN - 1] = 0;
        for (int p = 0; p < MAX_PAGES; p++) new_page_name[b][p][NAME_LEN - 1] = 0;
    }

    cJSON_Delete(root);

    s_cfg.bank_count = new_bank_count;
    memcpy(s_cfg.page_count, new_page_count, sizeof(new_page_count));
    memcpy(s_cfg.bank_name, new_bank_name, sizeof(new_bank_name));
    memcpy(s_cfg.page_name, new_page_name, sizeof(new_page_name));

    return nvs_save_v3(&s_cfg);
}

// ---------- JSON helpers (per-button) ----------
static bool parse_action(cJSON *o, action_t *a)
{
    if (!cJSON_IsObject(o) || !a) return false;

    const cJSON *type = cJSON_GetObjectItem(o, "type");
    const cJSON *ch   = cJSON_GetObjectItem(o, "ch");
    const cJSON *aa   = cJSON_GetObjectItem(o, "a");
    const cJSON *bb   = cJSON_GetObjectItem(o, "b");
    const cJSON *cc   = cJSON_GetObjectItem(o, "c");

    if (!cJSON_IsString(type) || !cJSON_IsNumber(ch) ||
        !cJSON_IsNumber(aa)   || !cJSON_IsNumber(bb) ||
        !cJSON_IsNumber(cc)) {
        return false;
    }

    a->ch = (uint8_t)ch->valueint;
    a->a  = (uint8_t)aa->valueint;
    a->b  = (uint8_t)bb->valueint;
    a->c  = (uint8_t)cc->valueint;

    if      (strcmp(type->valuestring, "cc") == 0)      a->type = ACT_CC;
    else if (strcmp(type->valuestring, "pc") == 0)      a->type = ACT_PC;
    else if (strcmp(type->valuestring, "note") == 0)    a->type = ACT_NOTE;
    else if (strcmp(type->valuestring, "delay") == 0)   a->type = ACT_DELAY;
    else if (strcmp(type->valuestring, "bank_pc") == 0) a->type = ACT_BANK_PC;
    else                                                a->type = ACT_NONE;

    return true;
}

static void action_to_json(cJSON *arr, const action_t *a)
{
    if (!arr || !a) return;
    if (a->type == ACT_NONE) return;

    const char *t = "none";
    if      (a->type == ACT_CC)      t = "cc";
    else if (a->type == ACT_PC)      t = "pc";
    else if (a->type == ACT_NOTE)    t = "note";
    else if (a->type == ACT_DELAY)   t = "delay";
    else if (a->type == ACT_BANK_PC) t = "bank_pc";

    cJSON *o = cJSON_CreateObject();
    cJSON_AddStringToObject(o, "type", t);
    cJSON_AddNumberToObject(o, "ch", a->ch);
    cJSON_AddNumberToObject(o, "a",  a->a);
    cJSON_AddNumberToObject(o, "b",  a->b);
    cJSON_AddNumberToObject(o, "c",  a->c);
    cJSON_AddItemToArray(arr, o);
}

esp_err_t config_store_get_btn_json(int bank, int page, int btn, char *out, int out_len)
{
    if (!out || out_len <= 0) return ESP_ERR_INVALID_ARG;

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    const btn_map_t *m = &s_cfg.map[bank][page][btn];

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "pressMode",  (int)m->press_mode);
    cJSON_AddNumberToObject(root, "ccBehavior", (int)m->cc_behavior);

    cJSON *sa = cJSON_CreateArray();
    cJSON *la = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "short", sa);
    cJSON_AddItemToObject(root, "long",  la);

    for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(sa, &m->short_actions[i]);
    for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(la, &m->long_actions[i]);

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) {
        free(s);
        return ESP_FAIL;
    }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}

esp_err_t config_store_set_btn_json(int bank, int page, int btn, const char *json)
{
    if (!json) return ESP_ERR_INVALID_ARG;

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *pm = cJSON_GetObjectItem(root, "pressMode");
    cJSON *cb = cJSON_GetObjectItem(root, "ccBehavior");
    cJSON *sa = cJSON_GetObjectItem(root, "short");
    cJSON *la = cJSON_GetObjectItem(root, "long");

    if (!cJSON_IsNumber(pm) || !cJSON_IsNumber(cb) || !cJSON_IsArray(sa) || !cJSON_IsArray(la)) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    btn_map_t *m = &s_cfg.map[bank][page][btn];

    int pressMode = clampi(pm->valueint, 0, 2); // ✅ 0..2
    int ccBeh     = clampi(cb->valueint, 0, 2);
    m->press_mode  = (btn_press_mode_t)pressMode;
    m->cc_behavior = (cc_behavior_t)ccBeh;

    for (int i = 0; i < MAX_ACTIONS; i++) {
        set_default_action(&m->short_actions[i]);
        set_default_action(&m->long_actions[i]);
    }

    int ns = cJSON_GetArraySize(sa);
    if (ns > MAX_ACTIONS) ns = MAX_ACTIONS;
    for (int i = 0; i < ns; i++) {
        if (!parse_action(cJSON_GetArrayItem(sa, i), &m->short_actions[i])) {
            cJSON_Delete(root);
            return ESP_FAIL;
        }
    }

    int nl = cJSON_GetArraySize(la);
    if (nl > MAX_ACTIONS) nl = MAX_ACTIONS;
    for (int i = 0; i < nl; i++) {
        if (!parse_action(cJSON_GetArrayItem(la, i), &m->long_actions[i])) {
            cJSON_Delete(root);
            return ESP_FAIL;
        }
    }

    cJSON_Delete(root);
    return nvs_save_v3(&s_cfg);
}


===== END FILE: C:\esp\my_host_project\my_app\main\config_store.c =====

===== FILE: C:\esp\my_host_project\my_app\spiffs\app.js =====
// ---------- safe DOM helpers ----------
function $(id) { return document.getElementById(id); }
function must(id) {
  const el = $(id);
  if (!el) throw new Error(`missing element id="${id}"`);
  return el;
}

let META = { maxBanks: 20, maxPages: 4, buttons: 8, bankCount: 1, maxActions: 20, longMs: 400 };
let LAYOUT = { bankCount: 1, banks: [] };

let cur = { bank: 0, page: 0, btn: 0 };
let MAP = null;

function wrap(n, max) {
  max = Math.max(1, Number(max || 1));
  let r = n % max;
  if (r < 0) r += max;
  return r;
}

function setMsg(text, ok = true) {
  const el = must("msg");
  el.textContent = text || "";
  el.className = "msg " + (ok ? "ok" : "bad");
}

async function apiGet(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

async function apiPost(url, obj) {
  const r = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(obj),
  });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

function curBankObj() { return (LAYOUT.banks || [])[cur.bank]; }
function curPageCount() {
  const b = curBankObj();
  return b ? (b.pageCount || 1) : 1;
}

function renderHeader() {
  must("curBank").textContent = cur.bank;
  must("curPage").textContent = cur.page;

  const b = curBankObj();
  must("curBankName").textContent = (b && b.name) ? b.name : "Bank";
  must("curPageName").textContent = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "Page";

  must("bankName").value = (b && b.name) ? b.name : "";
  must("pageName").value = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "";
}

function highlightGrid() {
  const pads = Array.from(must("btnGrid").querySelectorAll(".pad"));
  pads.forEach((p) => {
    const i = Number(p.dataset.idx);
    p.classList.toggle("active", i === cur.btn);
  });
}

function makeGridAndSelect() {
  const g = must("btnGrid");
  g.innerHTML = "";

  const sel = must("switchSelect");
  sel.innerHTML = "";

  const count = Number(META.buttons || 8);
  for (let i = 0; i < count; i++) {
    // grid button
    const b = document.createElement("button");
    b.className = "pad";
    b.textContent = String(i + 1);
    b.type = "button";
    b.dataset.idx = String(i);
    b.onclick = async () => {
      try {
        cur.btn = i;
        sel.value = String(i);
        highlightGrid();
        await loadButton();
      } catch (e) {
        setMsg("Load switch failed: " + e.message, false);
      }
    };
    g.appendChild(b);

    // dropdown option
    const o = document.createElement("option");
    o.value = String(i);
    o.textContent = `Switch ${i + 1}`;
    sel.appendChild(o);
  }

  sel.onchange = async () => {
    try {
      cur.btn = Number(sel.value || "0");
      highlightGrid();
      await loadButton();
    } catch (e) {
      setMsg("Load switch failed: " + e.message, false);
    }
  };

  sel.value = String(cur.btn);
  highlightGrid();
}

// ---------- action rows ----------
function setInputVisible(inp, visible) {
  inp.style.display = visible ? "" : "none";
}

function mkActionRow(action, onRemove) {
  const row = document.createElement("div");
  row.className = "action";

  const type = document.createElement("select");
  ["cc", "pc", "note", "delay", "bank_pc"].forEach((t) => {
    const o = document.createElement("option");
    o.value = t;
    o.textContent = t;
    type.appendChild(o);
  });
  type.value = action.type || "cc";

  const ch = document.createElement("input");
  ch.type = "number"; ch.min = 1; ch.max = 16;
  ch.value = (action.ch ?? 1);

  const a = document.createElement("input");
  a.type = "number"; a.min = 0; a.max = 255;
  a.value = (action.a ?? 0);

  const b = document.createElement("input");
  b.type = "number"; b.min = 0; b.max = 255;
  b.value = (action.b ?? 0);

  const c = document.createElement("input");
  c.type = "number"; c.min = 0; c.max = 255;
  c.value = (action.c ?? 0);

  const rm = document.createElement("button");
  rm.className = "x";
  rm.textContent = "×";
  rm.type = "button";
  rm.onclick = () => onRemove(row);

  function refresh() {
    // defaults
    setInputVisible(ch, true);
    setInputVisible(a, true);
    setInputVisible(b, true);
    setInputVisible(c, true);

    // numeric bounds typical
    ch.min = 1; ch.max = 16;
    a.min = 0; a.max = 127;
    b.min = 0; b.max = 127;
    c.min = 0; c.max = 127;

    if (type.value === "cc") {
      ch.placeholder = "ch"; a.placeholder = "cc"; b.placeholder = "val"; c.placeholder = "";
      setInputVisible(c, false); // ✅ ไม่มี cc behavior แล้ว => CC ใช้ b ค่าเดียว
    } else if (type.value === "pc") {
      ch.placeholder = "ch"; a.placeholder = "pc"; b.placeholder = ""; c.placeholder = "";
      setInputVisible(b, false);
      setInputVisible(c, false);
    } else if (type.value === "note") {
      ch.placeholder = "ch"; a.placeholder = "note"; b.placeholder = "vel"; c.placeholder = "dur×10ms";
      c.max = 255;
    } else if (type.value === "delay") {
      // ms=(a<<8|b)
      setInputVisible(ch, false);
      setInputVisible(c, false);
      a.placeholder = "ms_hi"; b.placeholder = "ms_lo";
      a.max = 255; b.max = 255;
    } else if (type.value === "bank_pc") {
      ch.placeholder = "ch"; a.placeholder = "pc"; b.placeholder = "lsb"; c.placeholder = "msb";
    }
  }

  type.onchange = refresh;
  refresh();

  row._get = () => ({
    type: type.value,
    ch: Number(ch.value || 1),
    a: Number(a.value || 0),
    b: Number(b.value || 0),
    c: Number(c.value || 0),
  });

  row.append(type, ch, a, b, c, rm);
  return row;
}

function renderActions(listEl, actions) {
  listEl.innerHTML = "";
  (actions || []).forEach((act) => {
    const row = mkActionRow(act, (r) => r.remove());
    listEl.appendChild(row);
  });
}

function collectActions(listEl) {
  const rows = Array.from(listEl.querySelectorAll(".action"));
  return rows.map((r) => r._get());
}

function listCount(listEl) {
  return listEl.querySelectorAll(".action").length;
}

function maxActions() {
  return Number(META.maxActions || 20);
}

function updateModeUI() {
  const pm = Number(must("pressMode").value || "0");

  const paneRight = must("paneRight");
  const leftTitle = must("leftTitle");
  const rightTitle = must("rightTitle");
  const addLeft = must("addLeft");
  const addRight = must("addRight");

  if (pm === 0) {
    // ✅ Short: ซ่อนทั้ง pane ขวา + ซ่อนปุ่ม addRight
    paneRight.style.display = "none";
    addRight.style.display = "none";

    leftTitle.textContent = "Commands";
    addLeft.textContent = `+ Add (max ${maxActions()})`;
  } else if (pm === 1) {
    paneRight.style.display = "";
    addRight.style.display = "";

    leftTitle.textContent = "Short";
    rightTitle.textContent = `Long (${META.longMs || 400}ms)`;
    addLeft.textContent = `+ Add Short (max ${maxActions()})`;
    addRight.textContent = `+ Add Long (max ${maxActions()})`;
  } else {
    paneRight.style.display = "";
    addRight.style.display = "";

    leftTitle.textContent = "A";
    rightTitle.textContent = "B";
    addLeft.textContent = `+ Add A (max ${maxActions()})`;
    addRight.textContent = `+ Add B (max ${maxActions()})`;
  }
}

function applyUIFromMap(m) {
  must("pressMode").value = String(m.pressMode ?? 0);
  renderActions(must("shortList"), m.short || []);
  renderActions(must("longList"), m.long || []);
  updateModeUI();
}

function readUIToMap() {
  const pm = Number(must("pressMode").value || "0");
  const shortArr = collectActions(must("shortList"));
  const longArr = (pm === 0) ? [] : collectActions(must("longList")); // ✅ short mode = ไม่ส่ง long

  // ✅ firmware ยังมี ccBehavior อยู่ แต่เว็บไม่ให้แก้แล้ว => fix ไว้ 0
  return {
    pressMode: pm,
    ccBehavior: 0,
    short: shortArr,
    long: longArr,
  };
}

// ---------- load/save ----------
async function loadMeta() {
  META = await apiGet("/api/meta");
}

async function loadLayout() {
  LAYOUT = await apiGet("/api/layout");

  const bc = Number(LAYOUT.bankCount || 1);
  LAYOUT.bankCount = bc;

  const rawBanks = (LAYOUT.banks || []).slice(0, bc);
  LAYOUT.banks = rawBanks.map((b, idx) => {
    const pc = Number((b && b.pageCount) ? b.pageCount : 1);
    const pages0 = (b && b.pages) ? b.pages : [];
    const pages = pages0.slice(0, pc).map((s) => String(s || "").slice(0, 15));
    while (pages.length < pc) pages.push("Page " + (pages.length + 1));

    return {
      index: idx,
      name: String((b && b.name) ? b.name : ("Bank " + (idx + 1))).slice(0, 15),
      pageCount: Math.max(1, Math.min(4, pc)),
      pages,
    };
  });

  while (LAYOUT.banks.length < bc) {
    const idx = LAYOUT.banks.length;
    LAYOUT.banks.push({
      index: idx,
      name: ("Bank " + (idx + 1)).slice(0, 15),
      pageCount: 1,
      pages: ["Page 1"],
    });
  }

  cur.bank = wrap(cur.bank, LAYOUT.bankCount);
  cur.page = wrap(cur.page, curPageCount());
}

async function saveLayout() {
  const payload = {
    bankCount: LAYOUT.bankCount,
    banks: LAYOUT.banks.map((b, idx) => ({
      index: idx,
      name: String(b.name || "").slice(0, 15),
      pageCount: b.pageCount,
      pages: (b.pages || []).slice(0, b.pageCount).map((s) => String(s || "").slice(0, 15)),
    })),
  };
  await apiPost("/api/layout", payload);
}

async function loadButton() {
  renderHeader();
  setMsg("Loading…");
  const url = `/api/button?bank=${cur.bank}&page=${cur.page}&btn=${cur.btn}`;
  MAP = await apiGet(url);

  // กัน map เก่า/ไม่ครบ
  if (!MAP || typeof MAP !== "object") MAP = { pressMode: 0, short: [], long: [] };
  if (!Array.isArray(MAP.short)) MAP.short = [];
  if (!Array.isArray(MAP.long)) MAP.long = [];

  applyUIFromMap(MAP);

  const b = curBankObj();
  const bn = (b && b.name) ? b.name : "Bank";
  const pn = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "Page";
  setMsg(`Loaded: ${bn} / ${pn} · Switch ${cur.btn + 1}`);
}

async function saveButton() {
  const url = `/api/button?bank=${cur.bank}&page=${cur.page}&btn=${cur.btn}`;
  const payload = readUIToMap();
  await apiPost(url, payload);
  setMsg("Saved ✅");
}

function tryAddRow(listEl) {
  if (listCount(listEl) >= maxActions()) {
    setMsg(`Max actions reached (${maxActions()})`, false);
    return;
  }
  const row = mkActionRow({ type: "cc", ch: 1, a: 0, b: 127, c: 0 }, (r) => r.remove());
  listEl.appendChild(row);
  setMsg("Added (remember to Save)");
}

async function pollLive() {
  try {
    const st = await apiGet("/api/state");
    must("liveBank").textContent = st.bank;
    must("livePage").textContent = st.page;
  } catch (_) {}
  setTimeout(pollLive, 500);
}

function setupUI() {
  must("bankMinus").onclick = async () => { cur.bank = wrap(cur.bank - 1, LAYOUT.bankCount); cur.page = wrap(cur.page, curPageCount()); await loadButton(); };
  must("bankPlus").onclick  = async () => { cur.bank = wrap(cur.bank + 1, LAYOUT.bankCount); cur.page = wrap(cur.page, curPageCount()); await loadButton(); };
  must("pageMinus").onclick = async () => { cur.page = wrap(cur.page - 1, curPageCount()); await loadButton(); };
  must("pagePlus").onclick  = async () => { cur.page = wrap(cur.page + 1, curPageCount()); await loadButton(); };

  must("btnAddBank").onclick = async () => {
    if (LAYOUT.bankCount >= (META.maxBanks || 20)) throw new Error("Max banks reached");
    const idx = LAYOUT.bankCount;
    LAYOUT.bankCount += 1;
    LAYOUT.banks.push({ index: idx, name: `Bank ${idx + 1}`, pageCount: 1, pages: ["Page 1"] });
    await saveLayout();
    await loadLayout();
    cur.bank = idx; cur.page = 0;
    await loadButton();
    setMsg("Added Bank ✅");
  };

  must("btnDelBank").onclick = async () => {
    if (LAYOUT.bankCount <= 1) throw new Error("Need at least 1 bank");
    LAYOUT.bankCount -= 1;
    LAYOUT.banks = LAYOUT.banks.slice(0, LAYOUT.bankCount);
    await saveLayout();
    await loadLayout();
    cur.bank = wrap(cur.bank, LAYOUT.bankCount);
    cur.page = wrap(cur.page, curPageCount());
    await loadButton();
    setMsg("Deleted Bank ✅");
  };

  must("btnAddPage").onclick = async () => {
    const b = curBankObj();
    if (!b) throw new Error("No bank");
    if (b.pageCount >= (META.maxPages || 4)) throw new Error("Max pages reached");
    b.pageCount += 1;
    b.pages = b.pages || [];
    b.pages.push(`Page ${b.pageCount}`);
    await saveLayout();
    await loadLayout();
    cur.page = b.pageCount - 1;
    await loadButton();
    setMsg("Added Page ✅");
  };

  must("btnDelPage").onclick = async () => {
    const b = curBankObj();
    if (!b) throw new Error("No bank");
    if (b.pageCount <= 1) throw new Error("Need at least 1 page");
    b.pageCount -= 1;
    b.pages = (b.pages || []).slice(0, b.pageCount);
    await saveLayout();
    await loadLayout();
    cur.page = wrap(cur.page, curPageCount());
    await loadButton();
    setMsg("Deleted Page ✅");
  };

  must("btnSaveNames").onclick = async () => {
    const b = curBankObj();
    if (!b) throw new Error("No bank");
    b.name = String(must("bankName").value || "").slice(0, 15);
    b.pages[cur.page] = String(must("pageName").value || "").slice(0, 15);
    await saveLayout();
    await loadLayout();
    renderHeader();
    setMsg("Saved names ✅");
  };

  must("addLeft").onclick = () => tryAddRow(must("shortList"));
  must("addRight").onclick = () => tryAddRow(must("longList"));

  must("btnSave").onclick = async () => {
    try { await saveButton(); }
    catch (e) { setMsg("Save failed: " + e.message, false); }
  };

  must("btnReload").onclick = async () => {
    try { await loadButton(); }
    catch (e) { setMsg("Reload failed: " + e.message, false); }
  };

  must("btnSyncFromLive").onclick = async () => {
    try {
      const st = await apiGet("/api/state");
      cur.bank = wrap(st.bank, LAYOUT.bankCount);
      cur.page = wrap(st.page, curPageCount());
      cur.btn = 0;
      must("switchSelect").value = "0";
      highlightGrid();
      await loadButton();
      setMsg("Synced from live ✅");
    } catch (e) {
      setMsg("Sync failed: " + e.message, false);
    }
  };

  must("pressMode").onchange = () => {
    updateModeUI();
    setMsg("Press mode changed (remember to Save)");
  };
}

window.addEventListener("load", async () => {
  try {
    setMsg("Init…");
    await loadMeta();
    await loadLayout();
    setupUI();
    makeGridAndSelect();
    renderHeader();
    await loadButton();
    pollLive();
  } catch (e) {
    // ✅ ถ้า js พัง จะเห็นสาเหตุชัด ๆ
    try { setMsg("INIT FAILED: " + e.message, false); }
    catch (_) { alert("INIT FAILED: " + e.message); }
  }
});


===== END FILE: C:\esp\my_host_project\my_app\spiffs\app.js =====

===== FILE: C:\esp\my_host_project\my_app\spiffs\index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Footswitch MIDI</title>
  <link rel="stylesheet" href="/style.css"/>
</head>
<body>
  <div class="wrap">
    <header class="top">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">Footswitch MIDI</div>
          <div class="sub">Captive portal setup</div>
        </div>
      </div>

      <div class="live">
        <div class="pill">Live: Bank <span id="liveBank">0</span> · Page <span id="livePage">0</span></div>
        <button class="btn ghost" id="btnSyncFromLive" type="button">Sync editor ← live</button>
      </div>
    </header>

    <section class="card">
      <div class="row space">
        <div class="group">
          <div class="label">Bank</div>
          <div class="stepper">
            <button class="btn" id="bankMinus" type="button">−</button>
            <div class="value">
              <div class="vnum">#<span id="curBank">0</span></div>
              <div class="vname" id="curBankName">Bank</div>
            </div>
            <button class="btn" id="bankPlus" type="button">+</button>
          </div>
          <div class="row">
            <button class="btn ghost" id="btnAddBank" type="button">+ Bank</button>
            <button class="btn ghost danger" id="btnDelBank" type="button">− Bank</button>
          </div>
        </div>

        <div class="group">
          <div class="label">Page</div>
          <div class="stepper">
            <button class="btn" id="pageMinus" type="button">−</button>
            <div class="value">
              <div class="vnum">#<span id="curPage">0</span></div>
              <div class="vname" id="curPageName">Page</div>
            </div>
            <button class="btn" id="pagePlus" type="button">+</button>
          </div>
          <div class="row">
            <button class="btn ghost" id="btnAddPage" type="button">+ Page</button>
            <button class="btn ghost danger" id="btnDelPage" type="button">− Page</button>
          </div>
        </div>

        <div class="group wide">
          <div class="label">Rename (Bank / Page)</div>
          <div class="row">
            <input class="inp" id="bankName" placeholder="Bank name (max 15 chars)"/>
            <input class="inp" id="pageName" placeholder="Page name (max 15 chars)"/>
            <button class="btn" id="btnSaveNames" type="button">Save names</button>
          </div>
          <div class="hint">
            Hardware combo: (5&6)=Bank−, (7&8)=Bank+, (6&7)=Page+ 🔁
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row space">
        <div class="group">
          <div class="label">Press mode</div>
          <select id="pressMode" class="sel">
            <option value="0">Short (show 1 box)</option>
            <option value="1">Short + Long (400ms)</option>
            <option value="2">Toggle (A/B alternate)</option>
          </select>
        </div>

        <!-- ✅ แทน CC Behavior ด้วยเลือกสวิตช์ -->
        <div class="group">
          <div class="label">Select switch</div>
          <select id="switchSelect" class="sel"></select>
          <div class="small" style="margin-top:6px;">or tap 1–8 buttons ➜</div>
        </div>

        <div class="group right">
          <div class="label">Switch (8)</div>
          <div class="grid" id="btnGrid"></div>
        </div>
      </div>

      <div class="row space" style="margin-top:10px;">
        <div class="small">
          Action fields: CC(a=CC#, b=val), PC(a=PC), Note(c=dur×10ms), Delay(ms=(a&lt;&lt;8|b)), bank_pc(a=PC,b=LSB,c=MSB)
        </div>
        <div class="row">
          <button class="btn primary" id="btnSave" type="button">Save</button>
          <button class="btn ghost" id="btnReload" type="button">Reload</button>
        </div>
      </div>

      <div class="split">
        <div id="paneLeft">
          <div class="h3" id="leftTitle">Commands</div>
          <div id="shortList" class="list"></div>
          <button class="btn ghost" id="addLeft" type="button">+ Add</button>
        </div>

        <div id="paneRight">
          <div class="h3" id="rightTitle">Long</div>
          <div id="longList" class="list"></div>
          <button class="btn ghost" id="addRight" type="button">+ Add</button>
        </div>
      </div>

      <div id="msg" class="msg"></div>
    </section>

    <footer class="foot">
      <div class="small">
        Note: โหมด Short จะไม่แสดง Long box ✅
      </div>
    </footer>
  </div>

  <script src="/app.js"></script>
</body>
</html>


===== END FILE: C:\esp\my_host_project\my_app\spiffs\index.html =====

===== FILE: C:\esp\my_host_project\my_app\spiffs\style.css =====
:root {
  --bg: #0f1115;
  --card: #171a21;
  --muted: #9aa3b2;
  --text: #e8ecf4;
  --line: #2a2f3a;
  --ok: #2ecc71;
  --bad: #ff5c5c;
}

* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  background: var(--bg);
  color: var(--text);
}

.wrap { max-width: 1100px; margin: 18px auto; padding: 0 14px; }

.top { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 14px; }
.brand { display: flex; gap: 10px; align-items: center; }
.dot { width: 12px; height: 12px; border-radius: 50%; background: var(--ok); }
.title { font-weight: 700; font-size: 18px; }
.sub { font-size: 12px; color: var(--muted); }

.live { display: flex; gap: 10px; align-items: center; }
.pill { padding: 8px 10px; border: 1px solid var(--line); border-radius: 999px; color: var(--muted); }

.card {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 16px;
  padding: 14px;
  margin-bottom: 14px;
}

.row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
.row.space { justify-content: space-between; }

.group { display: flex; flex-direction: column; gap: 8px; }
.group.wide { flex: 1; min-width: 280px; }
.group.right { min-width: 260px; }

.label { font-size: 12px; color: var(--muted); }

.stepper { display: flex; gap: 10px; align-items: center; }
.value .vnum { font-size: 12px; color: var(--muted); }
.value .vname { font-weight: 700; }

.btn {
  border: 1px solid var(--line);
  background: #202534;
  color: var(--text);
  padding: 8px 12px;
  border-radius: 12px;
  cursor: pointer;
  user-select: none;
}
.btn:hover { filter: brightness(1.08); }
.btn:active { transform: translateY(1px); }

.btn.primary { border-color: #3b82f6; background: #1f3d77; }
.btn.ghost { background: transparent; }
.btn.danger { border-color: var(--bad); color: var(--bad); }

.inp, .sel {
  border: 1px solid var(--line);
  background: #10131a;
  color: var(--text);
  padding: 9px 10px;
  border-radius: 12px;
  min-width: 220px;
}
.sel { min-width: 240px; }

.hint { font-size: 12px; color: var(--muted); }
.small { font-size: 12px; color: var(--muted); }

.grid {
  display: grid;
  grid-template-columns: repeat(4, 48px);
  gap: 10px;
  justify-content: start;
}
.pad {
  border: 1px solid var(--line);
  background: #10131a;
  color: var(--text);
  border-radius: 12px;
  padding: 10px 0;
  cursor: pointer;
}
.pad.active { border-color: #3b82f6; outline: 2px solid rgba(59,130,246,.25); }

.split {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin-top: 12px;
}
@media (max-width: 900px) {
  .split { grid-template-columns: 1fr; }
}

.h3 { font-weight: 700; margin-bottom: 8px; }

.list { display: flex; flex-direction: column; gap: 8px; }
.action {
  display: grid;
  grid-template-columns: 120px 90px 90px 90px 90px 40px;
  gap: 8px;
  align-items: center;
}
.action select, .action input {
  border: 1px solid var(--line);
  background: #10131a;
  color: var(--text);
  border-radius: 10px;
  padding: 8px 8px;
  width: 100%;
}
.action .x {
  border: 1px solid var(--line);
  background: transparent;
  color: var(--bad);
  border-radius: 10px;
  padding: 8px 0;
  cursor: pointer;
}

.msg { margin-top: 10px; font-size: 12px; color: var(--muted); }
.msg.ok { color: var(--ok); }
.msg.bad { color: var(--bad); }

.foot { margin-top: 10px; }


===== END FILE: C:\esp\my_host_project\my_app\spiffs\style.css =====

===== FILE: C:\esp\my_host_project\my_app\partitions.csv =====
# Name,   Type, SubType, Offset,  Size,    Flags
nvs,      data, nvs,     0x9000,  256K,
phy_init, data, phy,     0x49000, 4K,
factory,  app,  factory, 0x50000, 2M,
storage,  data, spiffs,  0x250000,0xDB0000,


===== END FILE: C:\esp\my_host_project\my_app\partitions.csv =====

